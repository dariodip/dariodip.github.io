<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Dario Di Pasquale</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Dario Di Pasquale</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 27 Mar 2020 09:11:00 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Ansible for developer 101</title>
            <link>/posts/2020/03/ansible-for-developer-101/</link>
            <pubDate>Fri, 27 Mar 2020 09:11:00 +0000</pubDate>
            
            <guid>/posts/2020/03/ansible-for-developer-101/</guid>
            <description>Introduction I started as a developer and I started to feel frustrating when I had to repeat something twice or more.
Being a developer does not mean you only have to write code. Hopefully, your code should be executed in different environments and often it is up to you managing part of those environments.
Nowadays automation brings a lot of improvements to the life-quality of developers. You can, therefore, exploit tools that help you repeating boring stuff, keeping you well focused on your work.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>I started as a developer and I started to feel frustrating when I had to repeat something twice or more.</p>

<p>Being a developer does not mean you only have to write code. Hopefully, your code should be executed in different environments and often it is up to you managing part of those environments.</p>

<p>Nowadays automation brings a lot of improvements to the life-quality of developers. You can, therefore, exploit tools that help you repeating boring stuff, keeping you well focused on your work.</p>

<p>Ansible is one of my favourite tools. He comes with a <em>gentle</em> learning curve and looks still familiar to developers since its concepts are quite similar to ones you use when writing code.</p>

<h2 id="ansible">Ansible</h2>

<p>Ansible is an automation platform that comes with an <em>automation language</em> that can describe an IT application infrastructure in <strong>Ansible Playbooks</strong>. An automation engine runs Ansible Playbooks.</p>

<p>Ansible also comes with <a href="https://www.ansible.com/products/tower"><strong>Ansible Tower</strong></a>: an enterprise framework for fully controlling, securing and managing your Ansible automation with a UI and RESTful API.</p>

<h3 id="why-ansible">Why Ansible?</h3>

<ul>
<li>Ansible is <a href="https://github.com/ansible/ansible"><em>Open Source</em></a> and has a large community;</li>
<li>Ansible has a gentle learning curve;</li>
<li>It gives you the ability to do automation in an (<em>almost</em>)-Human readable fashion;</li>
<li>No special coding skills needed unless you want to extend it;</li>
<li>Your tasks are executed in order;</li>
<li>Automation steps repeatable and testable in different environments;</li>
<li>You can manage the deployment and configuration of your application;</li>
<li>Ansible works with existing tools, so you can achieve a faster start;</li>
<li>It comes with over 500 included modules for the more common use cases;</li>
<li>You can orchestrate your workflow and application lifecycle.</li>
</ul>

<p>Unlike some of its competitors, Ansible is <em>agentless</em>. To execute tasks on another machine it can use <a href="https://www.openssh.com/"><strong>OpenSSH</strong></a> or <a href="https://docs.microsoft.com/en-us/windows/win32/winrm/portal"><strong>WinRM</strong></a>, so you don't have to take care of updating and managing agents, giving you a fast start and more control. It also brings to a more efficient and secure workflow.</p>

<p>Ansible is also <em>multiplatform</em> and supports all major OS variants.</p>

<h3 id="use-cases">Use cases</h3>

<ul>
<li><strong>Configuration management</strong>: centralizing configuration file management and deployment is a common use case for Ansible, and it’s how many power users are first introduced to the Ansible automation platform;</li>
<li><strong>Security and compliance</strong>: when you define your security policy in Ansible, scanning and remediation of site-wide security policy can be integrated into other automated processes and instead of being an afterthought, it’ll be integral in everything that is deployed;</li>
<li><strong>Application deployment</strong>: when you define your application with Ansible, and manage the deployment with Ansible Tower, teams are able to effectively manage the entire application lifecycle from development to production;</li>
<li><strong>Orchestration</strong>: configurations alone don’t define your environment. You need to define how multiple configurations interact and ensure the disparate pieces can be managed as a whole. Out of complexity and chaos, Ansible brings order;</li>
<li><strong>Continuous delivery</strong>: creating a CI/CD pipeline requires buy-in from numerous teams. You can’t do it without a simple automation platform that everyone in your organization can use. Ansible Playbooks keep your applications properly deployed (and managed) throughout their entire lifecycle;</li>
<li><strong>Provisioning</strong>: your apps have to live somewhere. If you’re PXE booting and kickstarting bare-metal servers or VMs, or creating virtual or cloud instances from templates, Ansible and Ansible Tower help streamline the process.</li>
</ul>

<h4 id="how-ansible-works">How Ansible works</h4>

<p>Ansible components follow a kind of hierarchical structure:</p>

<ul>
<li><strong>Managed Nodes</strong> are the network devices (and/or the servers) you manage with Ansible. Ansible does not need to be installed on this node;</li>
<li>The <strong>Inventory</strong> contains a structured set of managed nodes with optional attached metadata. Those hosts can be grouped together;</li>
<li><strong>Modules</strong> are units of code to be executed on the hosts specified in the inventory. You can invoke a single module with a task;</li>
<li>Modules are going to be contained in <strong>Tasks</strong>. Tasks are units of action in Ansible. You can execute a single task once with an ad-hoc command or more tasks using Playbooks;</li>
<li><strong>Playbooks</strong> are ordered lists of tasks, stored so you can run those tasks in that order repeatedly. Playbooks can include variables as well as tasks. Playbooks are written in YAML and are easy to read, write, share and understand.</li>
</ul>

<p>An important aspect of Ansible is that you don't have to know the underlying details behind modules. You just have to pass the correct arguments to them to be correctly executed. Some common modules are <a href="https://docs.ansible.com/ansible/latest/modules/apt_module.html"><strong>apt/yum</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/ping_module.html"><strong>ping</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/copy_module.html"><strong>copy</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/uri_module.html"><strong>uri</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/user_module.html"><strong>user</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/assert_module.html"><strong>assert</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/git_module.html"><strong>git</strong></a>, <a href="https://docs.ansible.com/ansible/latest/modules/template_module.html"><strong>template</strong></a> and so on. You can also check out the <a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html">Ansible Module Index</a>.</p>

<p>Those <strong>Modules</strong> are going to be used to act against an <strong>Inventory</strong>. You can also include inventory-specific data, making everything more reusable.</p>

<p>An example of static Inventory can be the following:</p>

<pre><code>[control]
control ansible_host=10.45.21.2

[web]
node1   ansible_host=10.43.21.0
node2   ansible_host=10.43.21.1
node3   ansible_host=10.43.21.2
node4   ansible_host=10.43.21.3

[haproxy]
haproxy ansible_host=10.43.20.0

[all:vars]
ansible_user=vagrant
ansible_ssh_private_key_file=~/.vagrant.d/private_key

[web:vars]
ansible_user=dario
</code></pre>

<p>This Inventory contains 3 groups that consist of a <code>control</code> node, four <code>web</code> nodes and an <code>HAProxy</code> node. Those nodes come with their IP address. Furthermore, you can specify a set of variables that apply to each node under the <code>all:vars</code> group and a set of variables that apply to each node in a group under the <code>web:vars</code>. Variables more specific have higher precedence.</p>

<p>Hosts specified in your inventory don't need to be aware of Ansible. These hosts can be any virtual or physical machine on an on-premise or public cloud having a Python interpreter installed, an <a href="https://docs.openstack.org/openstack-ansible/latest/">OpenStack</a> or <a href="https://docs.ansible.com/ansible/latest/scenario_guides/guide_vmware.html">VMware</a> cloud and so on.</p>

<p>Ansible is written in Python so we can extend it using plugins written in Python that use <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_api.html">Ansible API</a>.</p>

<h5 id="installing-ansible">Installing Ansible</h5>

<p>Before we start, we need to install Ansible. This is quite simple because you only have to run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pip install ansible</code></pre></div>
<p>Now to check if it works you have to run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ansible -v</code></pre></div>
<h5 id="adhoc-commands">Ad-Hoc Commands</h5>

<p>You can also execute some <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html"><strong>Ad-Hoc Commands</strong></a>. An Ansible ad-hoc command uses the <em>/usr/bin/ansible</em> command-line tool to automate a single task on one or more managed nodes. Ad-hoc commands are quick and easy, but they are not reusable.</p>

<p>An example of ad-hoc command could be the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ansible all -i hosts -u dario -m ping</code></pre></div>
<p>This command executes the <code>ping</code> module on the hosts specified in the inventory file called <code>hosts</code> using <code>dario</code> as the user. This can be used before running the full Ansible Playbook to ensure that your hosts are up and running. You could also run the module <code>setup</code> to gather facts without any modification to the target machine.</p>

<h5 id="variables">Variables</h5>

<p>Since Ansible was born to bring automation, automation often implies reusing. Reusing means, obviously, <strong>variables</strong>.
Ansible can work with metadata from various sources and manage their context in the form of <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html"><strong>variables</strong></a>.</p>

<p>Using variables you can also keep another layer of abstraction in your playbooks, separating information related to the execution and information related to hosts.</p>

<p>Once you defined a bunch of variables, they can be overridden by variables having higher precedence, so you could handle some special cases without having to break your reusable workflow. There are <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable">16 levels of precedence</a>. As the rule of thumb, the more specific is a variable, the higher is its precedence.</p>

<h5 id="ansible-playbooks">Ansible Playbooks</h5>

<p>As we said, <strong>Ansible Playbooks</strong> contains an ordered list of <strong>Ansible Tasks</strong> to be executed against hosts on your inventory. Let's see how a playbook works.</p>

<p>Let's construct a playbook step-by-step. First of all, we have to include the list of tasks:</p>

<h6 id="tasks">Tasks</h6>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">tasks:
    - name: add cache dir
      file:
        path: /opt/cache
        state: directory
    
    - name: install nginx
      yum:
        name: nginx
        state: latest
    
    - name: restart nginx
      service:
        name: nginx
        state: restarted</code></pre></div>
<p>In the preceding playbook we</p>

<ul>
<li>added a cache directory under <code>/opt/cache</code> using the <a href="https://docs.ansible.com/ansible/latest/modules/file_module.html"><code>file</code> module</a> giving the desired path as <code>path</code> variable and the desired state <code>directory</code> as variable <code>state</code>;</li>
<li>installed <code>nginx</code> using <code>yum</code> and the <a href="https://docs.ansible.com/ansible/latest/modules/yum_module.html">module of the same name</a>, setting the <code>state</code> variable to <code>nginx</code> and the <code>state</code> variable to <code>latest</code>, meaning that we want the latest version of <em>nginx</em> installed on the machine using <em>yum</em>;</li>
<li>restarted the <em>nginx</em> service using the <code>service</code> module and setting the variable <code>name</code> to be <code>nginx</code> and the variable <code>state</code> to be <code>restarted</code>. So we are saying we want the <code>nginx</code> service to be restarted on the machine.</li>
</ul>

<p>This example gives you a vision of the semantic of modules: you specify the desired state in a declarative way. It's up to the module to run the correct steps to bring the machine to the desired state. Furthermore, if we run the same playbook twice, nothing changes.
This outlines an important aspect of Ansible Tasks: they should be <a href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html"><strong>idempotent</strong></a>.</p>

<h6 id="handlers">Handlers</h6>

<p><strong>Handlers</strong> are special tasks that run at the end of a play if notified by another task. They can also be notified multiple time during the play but they will run only once at the end of the play. For example, you can ask to restart a service if the configuration gets changed.</p>

<p>Let's add an example handler to our playbook refactoring the preceding playbook:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">tasks:
    - name: add cache dir
      file:
        path: /opt/cache
        state: directory
    
    - name: install nginx
      yum:
        name: nginx
        state: latest
    notify: restart nginx
    
handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted</code></pre></div>
<p>Doing that, we ensure that the task <code>restart nginx</code> will be run only after the <code>install nginx</code> task has returned <code>changed</code> as its state.</p>

<h6 id="plays">Plays</h6>

<p><strong>Plays</strong> are ordered sets of tasks to execute against host selection from your inventory. A playbook contains one or more plays.</p>

<p>A playbook with <strong>Plays</strong> can be the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
- name: install and start apache
  hosts: web
  vars:
    http_port: <span style="color:#ae81ff">80</span>
    max_clients: <span style="color:#ae81ff">200</span>
  remote_user: root

  tasks:
  - name: install httpd
    yum: pkg=httpd state=latest
  - name: write the apache config file
    template: src=/srv/httpd.j2 dest=/etc/httpd.conf
  - name: start httpd
    service: name=http state=started</code></pre></div>
<ul>
<li>The upper <code>name</code> field is the name of the play;</li>
<li>The <code>hosts</code> field represents the group of the hosts in the inventory;</li>
<li>The <code>vars</code> map includes some variables that are going to be injected into the tasks. Those variables will be used to render the template in the <code>template</code> task;</li>
<li>We also specified the <code>remote_user</code> that has to run the tasks;</li>
<li><code>tasks</code> section includes the list of tasks to be executed. We used a more compact form to describe our tasks.</li>
</ul>

<h2 id="conclusions">Conclusions</h2>

<p>Having those concepts, you could start playing with Ansible. I will also talk about <strong>Ansible Roles</strong> in other posts.</p>
]]></content>
        </item>
        
        <item>
            <title>Data structures with Go - Part II</title>
            <link>/posts/2020/01/data-structures-with-go-part-ii/</link>
            <pubDate>Fri, 10 Jan 2020 17:05:35 +0000</pubDate>
            
            <guid>/posts/2020/01/data-structures-with-go-part-ii/</guid>
            <description>Data Structures With Go - Part II In the previous post we discussed how to implement linear data structures with Go.
Now we will explore two more complex data structures: tree and graph.
Those structures are not Linear and can represent unstructured information. Both graphs and trees are the foundation of the graph theory and both can be used, essentially, to describe a kind of relation.
In the domain of mathematics and computer science, graph theory is the study of graphs that concerns with the relationship among edges and vertices.</description>
            <content type="html"><![CDATA[<h2 id="data-structures-with-go--part-ii">Data Structures With Go - Part II</h2>

<p>In the <a href="/posts/2020/01/data-structures-with-go-part-i">previous post</a> we discussed how to implement linear data structures with Go.</p>

<p>Now we will explore two more complex data structures: <em>tree</em> and <em>graph</em>.</p>

<p>Those structures are not <em>Linear</em> and can represent unstructured information. Both <em>graph</em>s and <em>tree</em>s are the foundation of the <em>graph theory</em> and both can be used, essentially, to describe a kind of relation.</p>

<p>In the domain of <em>mathematics</em> and <em>computer science</em>, <strong>graph theory</strong> is the study of graphs that concerns with the relationship among edges and vertices. It is a popular subject having its applications in computer science, information technology, biosciences and mathematics to name a few.</p>

<p>The structures we will develop are only for educational purpose, you should not use them in production, also because some of them are already implemented in the <em>Go</em>'s standard library.</p>

<p>None of those structures is thread-safe. We will make them <em>thread-safe</em> in future posts (I wish).</p>

<p>Let's start by describing the most general one: the <strong>graph</strong>.</p>

<h3 id="graph">Graph</h3>

<p><figure><img src="/media/alvaro-pinot-czDvRp5V2b0-unsplash-min.jpg" alt="Graph" title="Photo by Alvaro Pinot on Unsplash"><figcaption>Photo by Alvaro Pinot on Unsplash</figcaption></figure></p>

<p>According to <a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">Wikipedia</a>:</p>

<blockquote>
<p>A graph data structure consists of a finite (and possibly mutable) set of vertices (also called nodes or points), together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges (also called links or lines), and for a directed graph are also known as arrows. The vertices may be part of the graph structure or may be external entities represented by integer indices or references.</p>
</blockquote>

<p>So a <em>graph</em> is be a set <span  class="math">\(G = (V,E)\)</span>, where <span  class="math">\(V\)</span> is a set of <em>vertex</em> (or <em>nodes</em>) and <span  class="math">\(E\)</span> is a set of <em>edges</em>. We will focus on the undirected graph, but creating a directed graph from an undirected one is quite easy.</p>

<p><figure><img src="/media/blog/p2/graph.png" alt="Graph" title="A graph"><figcaption>A graph</figcaption></figure></p>

<p>In the above graph, <span  class="math">\(V = (a, b, c, d, e)\)</span> and <span  class="math">\(E = ((a,b), (a,c), (c,d), (d,e), (e,a))\)</span>.</p>

<p>For a more detailed (and theoretical) description of graphs and their application, you could read the book <a href="https://www.pearson.com/us/higher-education/program/Kleinberg-Algorithm-Design/PGM319216.html">Algorithm Design</a>.</p>

<p>Now it's the coding time!</p>

<p>As usual, let's start with defining our structures:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">graph</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">value</span> <span style="color:#66d9ef">interface</span>{}
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Graph</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">nodes</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
	<span style="color:#a6e22e">edges</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">Node</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewGraph</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Graph</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Graph</span>{
		<span style="color:#a6e22e">nodes</span>: make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>, <span style="color:#ae81ff">0</span>),
		<span style="color:#a6e22e">edges</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">Node</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>),
	}
}</code></pre></div>
<p>As you can see from the code above, a <code>Node</code> is just a container for a value which is an <code>interface{}</code> so that we can use whatever type we want.</p>

<p>A <code>Graph</code>, instead, contains both an array of pointers to <code>Node</code>s and a <code>map</code> which has <code>Node</code>s as <em>key</em> and an array of pointers to <code>Node</code>s as value.</p>

<p>This definition follows naturally the formal definition, so we defined a <code>Graph</code> as a pair of <code>nodes</code> and <code>edges</code>.</p>

<p>The <code>NewGraph</code> function only initializes <code>nodes</code> and <code>edges</code>.</p>

<p>Let's see how to add <em>nodes</em> and <em>edges</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Graph</span>) <span style="color:#a6e22e">AddNode</span>(<span style="color:#a6e22e">el</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span> {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span>{<span style="color:#a6e22e">el</span>}
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">nodes</span> = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">nodes</span>, <span style="color:#a6e22e">n</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Graph</span>) <span style="color:#a6e22e">AddEdge</span>(<span style="color:#a6e22e">n1</span>, <span style="color:#a6e22e">n2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) {
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">edges</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">n1</span>] = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">edges</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">n1</span>], <span style="color:#a6e22e">n2</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">edges</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">n2</span>] = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">edges</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">n2</span>], <span style="color:#a6e22e">n1</span>)
}</code></pre></div>
<p>Both the <code>AddNode</code> and <code>AddEdge</code> methods are easy to understand.</p>

<p><code>AddNode</code> creates a <code>Node</code> which wraps the element, appends it to the <code>node</code> array and returns a pointer to that <code>Node</code>. This pointer can be useful next.</p>

<p><code>AddEdge</code> takes two pointers to <code>Node</code>s and appends them to the <code>edge</code> list in the <code>map</code> of each node.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">Node</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%v&#34;</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#a6e22e">Graph</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#a6e22e">sb</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">nodes</span> {
		<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">String</span>())
		<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34; -&gt; [ &#34;</span>)
		<span style="color:#a6e22e">neighbors</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">edges</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>]
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">u</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">neighbors</span> {
			<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">String</span>())
			<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34; &#34;</span>)
		}
		<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;]\n&#34;</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">String</span>()
}</code></pre></div>
<p>The <code>String</code> method for the <code>Node</code> is trivial, while the <code>String</code> method for a <code>Graph</code> needs a explanation. We first create a <code>strings.Builder</code> which is the most efficient way to store a string incrementally. We then iterate over each <code>Node</code> and over each <em>edge</em> of that node. Let's take the graph represented above: to create it in our code we could run the following snipped of code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewGraph</span>()
	<span style="color:#a6e22e">nA</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddNode</span>(<span style="color:#e6db74">&#34;a&#34;</span>)
	<span style="color:#a6e22e">nB</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddNode</span>(<span style="color:#e6db74">&#34;b&#34;</span>)
	<span style="color:#a6e22e">nC</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddNode</span>(<span style="color:#e6db74">&#34;c&#34;</span>)
	<span style="color:#a6e22e">nD</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddNode</span>(<span style="color:#e6db74">&#34;d&#34;</span>)
	<span style="color:#a6e22e">nE</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddNode</span>(<span style="color:#e6db74">&#34;e&#34;</span>)

	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddEdge</span>(<span style="color:#a6e22e">nA</span>, <span style="color:#a6e22e">nB</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddEdge</span>(<span style="color:#a6e22e">nA</span>, <span style="color:#a6e22e">nC</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddEdge</span>(<span style="color:#a6e22e">nA</span>, <span style="color:#a6e22e">nE</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddEdge</span>(<span style="color:#a6e22e">nC</span>, <span style="color:#a6e22e">nD</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">AddEdge</span>(<span style="color:#a6e22e">nD</span>, <span style="color:#a6e22e">nE</span>)

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">String</span>())</code></pre></div>
<p>Eventually, the <code>Print</code> statement will print the following:</p>

<pre><code>a -&gt; [ b c e ]
b -&gt; [ a ]
c -&gt; [ a d ]
d -&gt; [ c e ]
e -&gt; [ a d ]
</code></pre>

<h3 id="tree">Tree</h3>

<p><figure><img src="/media/blog/p2/tree-min.jpg" alt="Tree" title="Photo by Aaron Burden on Unsplash"><figcaption>Photo by Aaron Burden on Unsplash</figcaption></figure></p>

<p>According to <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">Wikipedia</a>:</p>

<blockquote>
<p>In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph. A forest is an undirected graph in which any two vertices are connected by at most one path, or equivalently an acyclic undirected graph, or equivalently a disjoint union of trees.</p>
</blockquote>

<p>Generally speaking, a <em>tree</em> is a <em>graph</em> without cycles on which we could define a <em>parent-children</em> relationship.</p>

<p>The recursive definition of a <em>tree</em> is:</p>

<blockquote>
<p>A tree is <span  class="math">\(empty\)</span> or a vertex <span  class="math">\(r\)</span> (the root of the tree) and a set of trees (the subtrees of <span  class="math">\(T\)</span>) whose roots are the children of <span  class="math">\(r\)</span>.</p>
</blockquote>

<p>This definition helps us to understand the basic structure of a <em>tree</em>. So we could decompose a <em>tree</em> in many <em>subtrees</em>.</p>

<p>A <em>tree</em> is a collection of nodes connected by directed edges. It is a nonlinear data structure, compared to arrays, linked lists, stacks and queues which are <a href="/posts/2020/01/data-structures-with-go-part-i">linear data structures</a>. A tree can be empty with no nodes or a tree is a structure consisting of one node called the root and zero or one or more subtrees. A tree has the following general properties:</p>

<ul>
<li>one node is distinguished as a root;</li>
<li>every node but the root is connected by a directed edge from exactly one other node;</li>
<li>a direction is: <span  class="math">\(parent \rightarrow children\)</span></li>
</ul>

<p><figure><img src="/media/blog/p2/tree-repr.png" alt="Tree" title="A tree"><figcaption>A tree</figcaption></figure></p>

<p>In the above <em>tree</em> we have a <strong>root</strong> <span  class="math">\(r\)</span> having <span  class="math">\(a\)</span>, <span  class="math">\(b\)</span> and <span  class="math">\(c\)</span> as child.
<em>Subtrees</em> of this <em>tree</em> are:</p>

<ul>
<li>(<span  class="math">\(a\)</span>, <span  class="math">\(d\)</span>), having <span  class="math">\(a\)</span> as the root and <span  class="math">\(d\)</span> as child of <span  class="math">\(a\)</span>;</li>
<li><span  class="math">\(b\)</span>, having <span  class="math">\(b\)</span> as the root and the empty tree as child of <span  class="math">\(b\)</span>;</li>
<li><span  class="math">\(c\)</span>, having <span  class="math">\(c\)</span> as the root and the empty tree as child of <span  class="math">\(c\)</span>;</li>
<li><span  class="math">\(d\)</span>, having <span  class="math">\(d\)</span> as the root and the empty tree as child of <span  class="math">\(d\)</span>.</li>
</ul>

<p>For a more detailed (and theoretical) description of trees and their application, you could read the book <a href="https://www.pearson.com/us/higher-education/program/Kleinberg-Algorithm-Design/PGM319216.html">Algorithm Design</a>.</p>

<p>Now let's translate this formal definition into code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">tree</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Tree</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">el</span> 		<span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">child</span> 	[]<span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>) <span style="color:#a6e22e">AddChild</span>(<span style="color:#a6e22e">el</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span> {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Tree</span>{<span style="color:#a6e22e">el</span>: <span style="color:#a6e22e">el</span>}
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">child</span> = append(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">child</span>, <span style="color:#a6e22e">c</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>
}</code></pre></div>
<p>Code for <code>Tree</code> is quite easy, isn't it?</p>

<p>Just think about the formal definition and see how we translate it in code:</p>

<p>A <code>Tree</code> struct contains an element <code>el</code> and a set (an array) of other <code>Tree</code>s (<code>child</code>). When we add a child to a <code>Tree</code> using the <code>AddChild</code> method we create a new <code>Tree</code> with <code>el</code> as the element and no child, then we append this <em>tree</em> to the root.</p>

<p>To represent the above tree, we could run the following snippet:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Tree</span>{<span style="color:#a6e22e">el</span>: <span style="color:#e6db74">&#34;r&#34;</span>}
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#e6db74">&#34;a&#34;</span>)
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#e6db74">&#34;d&#34;</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#e6db74">&#34;b&#34;</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">AddChild</span>(<span style="color:#e6db74">&#34;c&#34;</span>)</code></pre></div>
<p>Since this implementation is too easy, we'll see how to implement the search using both <em>BFS</em> (breadth-first search) and <em>DFS</em> (depth-first search).</p>

<h4 id="bfs">BFS</h4>

<p>The <em>BFS</em> algorithm visits our tree level by level. A possible visit to our tree could be the following:</p>

<p><figure><img src="/media/blog/p2/bfs.png" alt="BFS" title="A BFS visit"><figcaption>A BFS visit</figcaption></figure></p>

<p>Labels on the edges represent the order of visit.</p>

<p>The code for a <em>BFS</em> visit is the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>) <span style="color:#a6e22e">BFS</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>)) {
	<span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queue</span>.<span style="color:#a6e22e">Queue</span>{}
	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Enqueue</span>(<span style="color:#a6e22e">t</span>)
	<span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Empty</span>() {
		<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Dequeue</span>()
		<span style="color:#a6e22e">nextNode</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">next</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>)
		<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">nextNode</span>)
		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nextNode</span>.<span style="color:#a6e22e">child</span>) &gt; <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">child</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nextNode</span>.<span style="color:#a6e22e">child</span> {
				<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Enqueue</span>(<span style="color:#a6e22e">child</span>)
			}
		}
	}
}</code></pre></div>
<p>We create a <em>queue</em> containing all the nodes to be visited. The first node added is obviously <em>t</em> (the root). A <em>for</em> iterates over the queue and applies the function <em>f</em> passing the dequeued element <em>next</em>. After visiting the element <em>next</em>, its child will be added to the queue.</p>

<p>To print our <em>tree</em> using <em>BFS</em> we can run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>) {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">el</span>)
	})</code></pre></div>
<p>This will print:</p>

<pre><code>r
a
b
c
d
</code></pre>

<h4 id="dfs">DFS</h4>

<p>The <em>DFS</em> algorithm visits each node of the tree trying to Go as deep as he can, then <em>backtracking</em> when encounters a node with no children (a <em>leaf</em>). A possible visit to our tree could be the following:</p>

<p><figure><img src="/media/blog/p2/dfs.png" alt="DFS" title="A DFS visit"><figcaption>A DFS visit</figcaption></figure></p>

<p>Code for <em>DFS</em> is far more elegant that the one for <em>BFS</em> since it uses recursion:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>) <span style="color:#a6e22e">DFS</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>)) {
	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">t</span>)
	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">child</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">child</span> {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">DFS</span>(<span style="color:#a6e22e">f</span>)
		}
	}
}</code></pre></div>
<p>It first calls <code>f</code> passing <code>t</code>, then visits each child of <code>t</code> and calls <code>DFS</code> on each one.</p>

<p>To print our <em>tree</em> using <em>BFS</em> we can run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tree</span>) {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">el</span>)
	})</code></pre></div>
<p>This will print</p>

<pre><code>r
a
d
b
c
</code></pre>

<h3 id="conclusion">Conclusion</h3>

<p>Graphs and trees are powerful data structures since they allow you to store efficiently your data and their relationships. In literature, you can find so many different kinds of graphs and trees. A dept known of those structures makes you a better developer.</p>

<blockquote>
<p>&quot;The question of whether a computer can think is no more interesting than the question of whether a submarine can swim.&quot;</p>

<p><em>Edsger W. Dijkstra</em></p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Data structures with Go - Part I</title>
            <link>/posts/2020/01/data-structures-with-go-part-i/</link>
            <pubDate>Fri, 03 Jan 2020 17:05:35 +0000</pubDate>
            
            <guid>/posts/2020/01/data-structures-with-go-part-i/</guid>
            <description>Data Structures With Go - Part I Data structures are everywhere. Every developer should know them, starting from the most common ones.
The data structure priorly describes how the data is organised, accessed, associated and processed.
Using data structures you can keep your data in memory and efficiently access them.
You should pick the data structure that is the most suitable for your purposes to minimize space in memory and access time.</description>
            <content type="html"><![CDATA[<h2 id="data-structures-with-go--part-i">Data Structures With Go - Part I</h2>

<p><strong>Data structures</strong> are everywhere. Every developer should know them, starting from the most common ones.</p>

<p>The data structure priorly describes how the data is organised, accessed, associated and processed.</p>

<p>Using data structures you can keep your data in memory and efficiently access them.</p>

<p>You should pick the data structure that is the most suitable for your purposes to minimize space in memory and access time.</p>

<p>Some algorithms are designed upon certain data structures.</p>

<p>The critical part of developing such data structures in <strong>Go</strong> is the lack of generics. While other programming languages such as Java, C# etc. allow us to work with generics, <strong>Go</strong> has no way to do that, so we have to use the empty interface: <code>interface{}</code>.</p>

<p>Let's start with the most popular class of data structures: <strong>linear data structures</strong>.</p>

<p><strong>A Linear Data Structure</strong> arranges the data into a sequence and follows some sort of order.</p>

<p>The linear data structure is a single level data structure while non-linear data structures are the multilevel data structure.</p>

<p><figure><img src="/media/blog/linear_ds.jpg" alt="Linear Data Structure"></figure></p>

<p>The most popular <strong>Linear Data Structures</strong> are:</p>

<ul>
<li><a href="#stack">Stack</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#linked-list">Linked List</a></li>
<li><a href="#queue">Queue</a></li>
</ul>

<p>In this post, we will learn those Linear Data Structures and we will develop them using <em>Go</em>.</p>

<p>The structures we will develop are only for educational purpose, you should not use them in production, also because some of them are already implemented in the <em>Go</em>'s standard library.</p>

<p>None of those structures is thread-safe. We will make them <em>thread-safe</em> in future posts (I wish).</p>

<h3 id="stack">Stack</h3>

<p><figure><img src="/media/blog/stack_fun.jpg" alt="Photo by Whitney Wright on Unsplash" title="Photo by Whitney Wright on Unsplash"><figcaption>Photo by Whitney Wright on Unsplash</figcaption></figure></p>

<p>Beyond cookies, a <strong>stack</strong> or <em>LIFO</em> (last in, first out) is an abstract data type that serves as a collection of elements, with two principal operations:</p>

<ul>
<li><strong>push</strong>: adds an element to the collection. This method requires <em>O(1)</em>;</li>
<li><strong>top</strong>: returns the last element that was added without removing it. Requires <em>O(1)</em>;</li>
<li><strong>pop</strong>: removes the last element that was added. Requires <em>O(1)</em>;</li>
</ul>

<p>In a stack both the operations of <strong>push</strong> and <strong>pop</strong> takes place at the same end that is top of the stack. It can be implemented by using both array and linked list.</p>

<p>You can think a <strong>stack</strong> as a... stack. Yeah! Maybe the stack of plates is the best metaphor when thinking about this data structure.</p>

<p>In a stack of plates you can (and should at least if you don't want to break all your plates) access only the plate on the top. So you can put a plate on the top of the stack (<strong>push</strong>), you can take a plate on the top of the stack and get rid of it (<strong>pop</strong>) or you can observe the plate on the top of the stack without removing it (<strong>top</strong>).</p>

<p>Now let's develop our stack using <strong>Go</strong>!</p>

<p>Let's start defining our structure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">stack</span>

<span style="color:#75715e">// Stack is the structure which contains our elements
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Stack</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">stack</span> 	[]<span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">curInd</span> 	<span style="color:#66d9ef">int</span>
}</code></pre></div>
<p>The best way to implement a stack is by using an <strong>array</strong> and an <code>int</code> which indexes the top of the stack.
To simplify stack's operations we assume that when the index is <code>-1</code> the stack is empty and when the stack is full we cannot insert other elements.</p>

<p>If you want to avoid the latter limitation, you should either control the size of the array dynamically or you should use another structure such as a linked list.</p>

<p>The following image shows the empty stack, i.e. the one with no elements and <code>curInt</code> equals to <code>-1</code>.</p>

<p><figure><img src="/media/blog/empty_stack.png" alt="Empty stack" title="Empty stack"><figcaption>Empty stack</figcaption></figure></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// NewStack returns a pointer to a new stack having:
</span><span style="color:#75715e">// - the array initialized with the provided size
</span><span style="color:#75715e">// - the current index initialized with -1 (empty stack)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewStack</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Stack</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Stack</span>{
		<span style="color:#a6e22e">stack</span>: make([]<span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">size</span>),
		<span style="color:#a6e22e">curInd</span>: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
	}
}

<span style="color:#75715e">// IsEmpty returns true if the stack is empty
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Stack</span>) <span style="color:#a6e22e">IsEmpty</span>() <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span> &lt; <span style="color:#ae81ff">0</span>
}</code></pre></div>
<p>The function <code>NewStack</code> takes an <code>int</code> as argument and returns a pointer to a stack having both array and top's index initialized.</p>

<p>The method <code>IsEmpty</code> is quite simplistic: it returns <code>true</code> if <code>curInd</code> is less than <code>0</code>, otherwise it returns false.</p>

<p>Now let's dive into the core methods of the <strong>stack</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Top returns the element at the top of the stack without removing it. 
</span><span style="color:#75715e">// This method panics if the stack is empty
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Stack</span>) <span style="color:#a6e22e">Top</span>() <span style="color:#66d9ef">interface</span>{} {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">IsEmpty</span>() {
		panic(<span style="color:#e6db74">&#34;stack is empty&#34;</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">stack</span>[<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span>]
}

<span style="color:#75715e">// Pop removes and returns the element at the top of the stack. 
</span><span style="color:#75715e">// This method panics if the stack is empty
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Stack</span>) <span style="color:#a6e22e">Pop</span>() <span style="color:#66d9ef">interface</span>{} {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">IsEmpty</span>() {
		panic(<span style="color:#e6db74">&#34;stack is empty&#34;</span>)
	}
	<span style="color:#a6e22e">el</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">stack</span>[<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span>]
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">stack</span>[<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span>] = <span style="color:#66d9ef">nil</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span><span style="color:#f92672">--</span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">el</span>
}

<span style="color:#75715e">// Push inserts the element at the top of the stack. 
</span><span style="color:#75715e">// This method panics if the stack is full
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Stack</span>) <span style="color:#a6e22e">Push</span>(<span style="color:#a6e22e">el</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span><span style="color:#f92672">++</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">stack</span>[<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">curInd</span>] = <span style="color:#a6e22e">el</span>
}</code></pre></div>
<p>The method <code>Top</code> returns an interface but does not alter the stack. It first checks if the stack is empty, if so it panics, otherwise returns the element of the underlying array at the index specified by <code>curInd</code>.</p>

<p>The method <code>Pop</code> is similar to its relative <code>Top</code> but &quot;<em>deletes</em>&quot; the element at the top. Actually, this method stores the element at <code>curInd</code> in a temporary variable <code>el</code>, sets the location at <code>curInd</code> to <code>nil</code> (<em>garbage collector</em> will do the tough job) and decrements <code>curInd</code>, finally returns <code>el</code>.</p>

<p>The method <code>Push</code> does the opposite: it increments <code>curInd</code> and sets the element at location <code>curInd</code> of the <code>stack</code> array to be the element taken as the argument.</p>

<p>The following image shows a stack with a single element, so <code>curInd</code> is <code>0</code> (namely, the first location of the array):</p>

<p><figure><img src="/media/blog/one_elem_stack.png" alt="One element stack" title="One element stack"><figcaption>One element stack</figcaption></figure></p>

<p>The following image shows a stack with two elements, so <code>curInd</code> is <code>1</code>:</p>

<p><figure><img src="/media/blog/two_elem_stack.png" alt="Two element stack" title="Two element stack"><figcaption>Two element stack</figcaption></figure></p>

<h3 id="array">Array</h3>

<p><figure><img src="/media/blog/array_fun.jpg" alt="Photo by A. L. on Unsplash" title="Photo by A. L. on Unsplash"><figcaption>Photo by A. L. on Unsplash</figcaption></figure></p>

<p><strong>Array</strong> is a data structure used to store homogeneous elements at contiguous locations. Size of an array can be provided before storing data or the array can dynamically adapt its size to keep all the elements.</p>

<p>Operations on the array are:</p>

<ul>
<li><strong>access</strong>: returns the element indexed by a given index <em>i</em> and requires <em>O(1)</em>;</li>
<li><strong>search</strong>: returns the index of a given element and requires <em>O(n)</em> in the worst case;</li>
<li><strong>insertion</strong>: inserts an element in the array at a given index <em>i</em>. This method requires <em>O(n)</em> in the worst case, namely when insertion happens at the beginning of the array and requires shifting of all the elements;</li>
<li><strong>deletion</strong>: deletes an element in the array at a given index <em>i</em>. This method requires <em>O(n)</em> in the worst case, namely when deletion happens at the beginning of the array and requires shifting of all the elements.</li>
</ul>

<p>Since Go already has the <code>array</code> data structure, it does not make any sense to develop our array. However, the <code>array</code> of Go does not have the <code>search</code> method, so we'll develop it!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">array</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SearchArray</span> []<span style="color:#66d9ef">interface</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">SearchArray</span>) <span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">el</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">el</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
}</code></pre></div>
<p>The method <code>Search</code> is very simplistic: it iterates over the elements of the array and, if this element is equal to the element <code>el</code> passed as the argument, returns its index. If the method does not find the element <code>el</code> returns <code>-1</code>.</p>

<h3 id="linked-list">Linked List</h3>

<p><figure><img src="/media/blog/linked_list_fun.jpg" alt="Photo by JJ Ying on Unsplash" title="Photo by JJ Ying on Unsplash"><figcaption>Photo by JJ Ying on Unsplash</figcaption></figure></p>

<p>A <strong>Linked List</strong> is a linear data structure (like arrays) where each element is a separate object. Each element, called <strong>node</strong>, of a list is comprising of two items: the data and a reference to the next node.</p>

<p>There are different kinds of <strong>Linked List</strong>, but we will explore only the most popular one: <strong>Single Linked List</strong>.</p>

<p>Operations on <strong>Linked List</strong>s are:</p>

<ul>
<li><strong>access</strong>: accessing elements in a linked list requires <em>O(n)</em> in the worst case. Actually, to access element <em>i</em> of a linked list requires <em>O(i)</em>;</li>
<li><strong>search</strong>: searching elements in a linked list requires <em>O(n)</em> in the worst case, namely when the element we are looking for is the latter element of the linked list;</li>
<li><strong>insertion</strong>: insertion of an element at the position <em>i</em> requires <em>O(i)</em>;</li>
<li><strong>deletion</strong>: deletion of an element at the position <em>i</em> requires <em>O(i)</em>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">linked_list</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">el</span> 	 <span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LinkedList</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">head</span> 	<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
}</code></pre></div>
<p>The building blocks of our <strong>Linked List</strong> are <em>Node</em>s. A node contains an element (<code>el</code>) and a reference to the next node (<code>next</code>) in the list. In that way we could iterate over our list starting from a node.</p>

<p>The <code>LinkedList</code> itself only contains a reference to a node which is the first of the list (<code>head</code>).</p>

<p>The following image explains the structure of a linked list:</p>

<p><figure><img src="/media/blog/linked_list_memory.png" alt="Linked List" title="Linked List"><figcaption>Linked List</figcaption></figure></p>

<p>Now let's dive into its methods:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">LinkedList</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">interface</span>{} {
	<span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">pos</span> &lt; <span style="color:#a6e22e">i</span>; <span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cur</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {	<span style="color:#75715e">// limit exceeded
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
		}
		<span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">next</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">el</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">LinkedList</span>) <span style="color:#a6e22e">Search</span>(<span style="color:#a6e22e">e</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">el</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">e</span> {
		<span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">next</span>
		<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pos</span>
}</code></pre></div>
<p><code>Get</code> and <code>Search</code> are quite similar: we start from the <em>head</em> and move to the next node until we reach the right position or find the element we are looking for. A temporary variable called <code>cur</code> (<em>by convention</em>) initially points to <code>head</code>, then to its <code>next</code>, then to the <code>next</code>'s <code>next</code> and so on.</p>

<h4 id="add">Add</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">LinkedList</span>) <span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">e</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Node</span>{<span style="color:#a6e22e">el</span>: <span style="color:#a6e22e">e</span>}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>
		<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>
	<span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
	<span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">pos</span> &lt; <span style="color:#a6e22e">i</span> {
		<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span>
		<span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">next</span>
		<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
	}
	<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
	<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">cur</span>
}</code></pre></div>
<p>The <code>Add</code> method requires a detailed explanation. We first create a new node <code>n</code> putting the element <code>e</code> into it. Then we have to discriminate between two cases:</p>

<ul>
<li>if <code>i == 0</code> we have to change the head of the list, so <code>n</code> points to the old head and <code>l.head</code> points to <code>n</code>;</li>
<li>if <code>i &gt; 0</code> have to keep two variables: <code>prev</code> which is the head initially and <code>cur</code> which is the <code>prev</code>'s next. We must keep both <code>prev</code> and <code>cur</code> because the insertion of a node requires to change both. <code>pos</code> is the current position and starts to <code>1</code> (yes, because we know that <code>i &gt; 0</code>). Until <code>pos &lt; i</code>, we advance both <code>prev</code> and <code>cur</code> making them pointing to their <code>next</code>s and incrementing <code>pos</code>. When <code>pos</code> is equal to <code>i</code> we update <code>prev</code>'s <code>next</code> to point to <code>n</code> and <code>n</code>'s <code>next</code> to point to <code>cur</code>.</li>
</ul>

<p>The following images may clarify this concept:</p>

<p>Our Linked List before <code>Add</code>:</p>

<p><figure><img src="/media/blog/linked_list.png" alt="Add Linked List" title="Linked List"><figcaption>Linked List</figcaption></figure></p>

<p>Our Linked List after <code>Add</code> an element in position <code>1</code>:</p>

<p><figure><img src="/media/blog/linked_list_add.png" alt="Add Linked List" title="Linked List after Add"><figcaption>Linked List after Add</figcaption></figure></p>

<h3 id="delete">Delete</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">LinkedList</span>) <span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {	<span style="color:#75715e">// deleting the head
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>
	<span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
	<span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">pos</span> &lt; <span style="color:#a6e22e">i</span> {
		<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span>
		<span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">next</span>
		<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
	}
	<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">next</span>
}</code></pre></div>
<p>The <code>Delete</code> method is quite similar to <code>Add</code> but does the opposite. The elimination of the variable from the memory is up to the garbage collector.</p>

<ul>
<li>if <code>i == 0</code>, <code>l.head</code> points to <code>l.head.next</code>;</li>
<li>if <code>i &gt; 0</code>, we iterate until we reach the desired position, then we make <code>prev.next</code> to point to <code>cur.next</code>: doing that we ensure that the element to be removed will never be pointed again by our list.</li>
</ul>

<p>The following images may clarify this concept:</p>

<p>Our Linked List before <code>Delete</code>:</p>

<p><figure><img src="/media/blog/linked_list.png" alt="Add Linked List" title="Linked List"><figcaption>Linked List</figcaption></figure></p>

<p>Our Linked List after <code>Delete</code> an element in position <code>1</code>:</p>

<p><figure><img src="/media/blog/linked_list_remove.png" alt="Add Linked List" title="Linked List after Delete"><figcaption>Linked List after Delete</figcaption></figure></p>

<h4 id="bonus-string">Bonus: String</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">LinkedList</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
	<span style="color:#a6e22e">sb</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Builder</span>{}
	<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#e6db74">&#34;[ &#34;</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>; <span style="color:#a6e22e">cur</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">next</span> {
		<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%v &#34;</span>, <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">el</span>))
	}
	<span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">WriteByte</span>(<span style="color:#e6db74">&#39;]&#39;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sb</span>.<span style="color:#a6e22e">String</span>()
}</code></pre></div>
<p>The <code>String</code> method shows how to iterate over a list using a <code>for</code> loop.</p>

<h3 id="queue">Queue</h3>

<p><figure><img src="/media/blog/queue_fun.jpg" alt="Photo by Mael BALLAND on Unsplash" title="Photo by Mael BALLAND on Unsplash"><figcaption>Photo by Mael BALLAND on Unsplash</figcaption></figure></p>

<p>A queue or <em>FIFO</em> (first in, first out) is an abstract data type that serves as a collection of elements, with two principal operations:</p>

<ul>
<li><strong>enqueue</strong>: the process of adding an element to the collection. The element is added from the rear side. This method requires <em>O(1)</em>;</li>
<li><strong>dequeue</strong>: the process of removing the first element that was added. The element is removed from the front side. Requires <em>O(1)</em>.</li>
</ul>

<p>It can be implemented by using both array and linked list. Our implementation will be based on a Linked List.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">queue</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;strings&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">el</span> <span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Queue</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
	<span style="color:#a6e22e">tail</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
}</code></pre></div>
<p>The implementation for <code>Queue</code> is obviously similar to the one for <code>LinkedList</code> but we also store another pointer to the <code>tail</code> which is the side from which we insert new elements.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Queue</span>) <span style="color:#a6e22e">Enqueue</span>(<span style="color:#a6e22e">e</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Node</span>{<span style="color:#a6e22e">el</span>: <span style="color:#a6e22e">e</span>}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">tail</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">head</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
		<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">tail</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">tail</span>.<span style="color:#a6e22e">next</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">tail</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
}</code></pre></div>
<p>The <code>Enqueue</code> method first creates a new <em>Node</em> <code>n</code>, then, if <code>q.tail == nil</code> (the queue is empty) makes both <code>q.head</code> and <code>q.tail</code> to point to the new node, otherwise makes both <code>q.tail</code> and <code>q.tail.next</code> to point to the new node.</p>

<p>It is worth noting that <code>q.tail</code> is the latter inserted node, so its <code>next</code> previously pointed to <code>nil</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Queue</span>) <span style="color:#a6e22e">Dequeue</span>() <span style="color:#66d9ef">interface</span>{}{
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">head</span>
	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">tail</span> = <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">el</span>
}</code></pre></div>
<p>The <code>Dequeue</code> method first checks if <code>q.head == nil</code>, so we have an empty queue and it must return <code>nil</code>, otherwise it stores the <code>q.head</code> value to a temporary variable <code>n</code>, checks if its <code>next</code> pointer is nil (single element queue) (if so makes <code>q.tail</code> pointing to nil to have an empty queue). Finally it returns the <code>el</code> value of <code>n</code>.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Different data structures bring different advantages. You should know when to pick one rather than another and this <em>knowledge</em> comes with experience. However, it is not hard to understand the benefits that come with those simple data structures:</p>

<ul>
<li><strong>Stacks</strong> are great when you have to remember the steps you did. In fact, you can store (<em>push</em>) your steps in a stack and go back the same way (<em>pop</em>);</li>
<li><strong>Arrays</strong> are great when you need random access. In fact, they require only <em>O(1)</em> for retrieving an element at any desired position;</li>
<li><strong>LinkedLists</strong> are great when you need to insert or remove elements the front. By contrast, arrays are not suitable for those operations because they have to move most of the elements;</li>
<li><strong>Queues</strong> are great when you have to memorize elements and consume them later keeping the order you produced them.</li>
</ul>

<p>I wish this post would help beginner developers using the correct data structure for their algorithms.</p>

<blockquote>
<p>&quot;It is easier to change the specification to fit the program than vice versa.&quot;</p>

<p><em>Alan Perlis</em></p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Binary Search with Go, Python and C</title>
            <link>/posts/2019/12/binary-search-with-go-python-and-c/</link>
            <pubDate>Sun, 01 Dec 2019 17:05:35 +0000</pubDate>
            
            <guid>/posts/2019/12/binary-search-with-go-python-and-c/</guid>
            <description>The Binary Search Algorithm The Binary Search Algorithm is a search algorithm that works for sorted collections (e.g. sorted arrays). It takes as input a collection, the length of that collection and an element to find, and gives as output the index of the element in the collection (if it exists).
This algorithm is as efficient as easy to learn due to its simplicity.
This algorithm does only O(log n) comparisons.</description>
            <content type="html"><![CDATA[<h2 id="the-binary-search-algorithm">The Binary Search Algorithm</h2>

<p>The <em>Binary Search Algorithm</em> is a search algorithm that works for sorted collections (e.g. sorted arrays). It takes as input a collection, the length of that collection and an element to find, and gives as output the index of the element in the collection (if it exists).</p>

<p>This algorithm is as efficient as easy to learn due to its simplicity.</p>

<p>This algorithm does only <em>O(log n)</em> comparisons.</p>

<p>On the other hand, it only works for sorted collections, making it restricted to some specific cases.</p>

<h3 id="pseudocode">Pseudocode</h3>

<p>The pseudocode for the algorithm is the following:</p>

<pre><code>    function BSA(A, n, T):
        L := 0
        R := n − 1
        while L &lt;= R:
            m := floor((L + R) / 2)
            if A[m] &lt; T:
                L := m + 1
            else if A[m] &gt; T:
                R := m - 1
            else:
                return m
        return unsuccessful
</code></pre>

<p>Let's explain this pseudocode:</p>

<ul>
<li>The algorithm takes as input an array <code>A</code>, the length of the array <code>n</code> and the element to search <code>T</code>;</li>
<li>We initialize two variables: <code>L</code> to <code>0</code> and <code>R</code> to <code>n-1</code>, namely the index to the first and the last element to the array <code>A;</code></li>
<li>We iterate until <code>L</code> becomes equal or greater than <code>R</code>, that is when we iterated over the whole array;</li>
<li>We initialize <code>m</code> to be the floor or <code>(L+R)/2</code>, namely the index of the element at the middle of the array;</li>
<li>Then we compare the element at the index <code>m</code> to the desired element <code>T</code>:

<ul>
<li>if <code>A[m]</code> is lower than <code>T</code> we should search <code>T</code> in the greater half of the array: the one in <em>[m+1, R]</em>;</li>
<li>if <code>A[m]</code> is greater than <code>T</code> we should search <code>T</code> in the lower half of the array: the one in <em>[L,m-1]</em>;</li>
<li>otherwise <code>A[m]</code> is equal to <code>T</code> and we can return <code>m</code> because we found the element.</li>
</ul></li>
</ul>

<h3 id="python">Python</h3>

<p>Let's have a look at the BSA using Python.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    <span style="color:#f92672">from</span> math <span style="color:#f92672">import</span> floor
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bsa</span>(l, n, t):
        L <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        R <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> L <span style="color:#f92672">&lt;=</span> R:
            m <span style="color:#f92672">=</span> floor((L <span style="color:#f92672">+</span> R) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
            <span style="color:#66d9ef">if</span> A[m] <span style="color:#f92672">&lt;</span> T:
                L <span style="color:#f92672">=</span> m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> A[m] <span style="color:#f92672">&gt;</span> T:
                R <span style="color:#f92672">=</span> m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">return</span> m
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span></code></pre></div>
<p>As you may see, the <em>BSA</em> written in Python is very similar to the pseudocode. We return <code>-1</code> when we cannot find the desired element.</p>

<h3 id="go">Go</h3>

<p>The <em>Go</em> version of the <em>BSA</em> is the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bsa</span>(<span style="color:#a6e22e">A</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
        <span style="color:#a6e22e">L</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#a6e22e">R</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">L</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">R</span> {
            <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Floor</span>(float64((<span style="color:#a6e22e">L</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">R</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)))
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">m</span>] &lt; <span style="color:#a6e22e">T</span> {
                <span style="color:#a6e22e">L</span> = <span style="color:#a6e22e">m</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">A</span>[<span style="color:#a6e22e">m</span>] &gt; <span style="color:#a6e22e">T</span> {
                <span style="color:#a6e22e">R</span> = <span style="color:#a6e22e">m</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>
            }
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    }</code></pre></div>
<p>Unlike the <em>Python</em> version, this code does not look similar to the pseudocode because of Go's strong typing, which forces us to do 2 casts (<em>line 5</em>). Also in the <em>Go</em> implementation we return <code>-1</code> if we cannot find the element <code>T</code>. Due to the simplicity of the algorithm itself, no other consideration has to be made.</p>

<h3 id="c">C</h3>

<p>The <em>C</em> version of the <em>BSA</em> could be the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsa</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> T) {
        <span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, R <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (L <span style="color:#f92672">&lt;=</span> R) {
            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (L <span style="color:#f92672">+</span> R) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span> (A[m] <span style="color:#f92672">&lt;</span> T) {
                L <span style="color:#f92672">=</span> m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (A[m] <span style="color:#f92672">&gt;</span> T) {
                R <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">return</span> m;
            }
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }</code></pre></div>
<p>The <em>C</em> implementation looks quite similar to the <em>Go</em> implementation but does not have casts because <em>C</em> has weak typing.</p>

<hr>

<p>This is my first blog post.</p>
]]></content>
        </item>
        
    </channel>
</rss>

<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="light">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Data structures with Go - Part II | Dario Di Pasquale</title>
<meta name="keywords" content="algorithms, go, golang, data structures, basic, beginner">
<meta name="description" content="A brief introduction to data structures using Go - Part II">
<meta name="author" content="Dario Di Pasquale">
<link rel="canonical" href="https://dariodip.com/posts/algorithms/a-brief-introduction-to-data-structures-using-go-part-ii/">
<link crossorigin="anonymous" href="https://dariodip.com/assets/css/stylesheet.bb7f6478ba46d26b0f1f3447787b7e671e6444b826d19a0ca5fcd12b6444d016.css" integrity="sha256-u39keLpG0msPHzRHeHt&#43;Zx5kRLgm0ZoMpfzRK2RE0BY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dariodip.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dariodip.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dariodip.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dariodip.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://dariodip.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dariodip.com/posts/algorithms/a-brief-introduction-to-data-structures-using-go-part-ii/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-SRBGH8203N"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-SRBGH8203N');
        }
      </script><meta property="og:url" content="https://dariodip.com/posts/algorithms/a-brief-introduction-to-data-structures-using-go-part-ii/">
  <meta property="og:site_name" content="Dario Di Pasquale">
  <meta property="og:title" content="Data structures with Go - Part II">
  <meta property="og:description" content="A brief introduction to data structures using Go - Part II">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-01-10T17:05:35+00:00">
    <meta property="article:modified_time" content="2020-01-10T17:05:35+00:00">
    <meta property="article:tag" content="Algorithms">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="Golang">
    <meta property="article:tag" content="Data Structures">
    <meta property="article:tag" content="Basic">
    <meta property="article:tag" content="Beginner">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data structures with Go - Part II">
<meta name="twitter:description" content="A brief introduction to data structures using Go - Part II">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dariodip.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Data structures with Go - Part II",
      "item": "https://dariodip.com/posts/algorithms/a-brief-introduction-to-data-structures-using-go-part-ii/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Data structures with Go - Part II",
  "name": "Data structures with Go - Part II",
  "description": "A brief introduction to data structures using Go - Part II",
  "keywords": [
    "algorithms", "go", "golang", "data structures", "basic", "beginner"
  ],
  "articleBody": "Data Structures With Go - Part II This page has been migrated to Medium In the previous post we discussed how to implement linear data structures with Go.\nNow we will explore two more complex data structures: tree and graph.\nThose structures are not Linear and can represent unstructured information. Both graphs and trees are the foundation of the graph theory and both can be used, essentially, to describe a kind of relation.\nIn the domain of mathematics and computer science, graph theory is the study of graphs that concerns with the relationship among edges and vertices. It is a popular subject having its applications in computer science, information technology, biosciences and mathematics to name a few.\nThe structures we will develop are only for educational purpose, you should not use them in production, also because some of them are already implemented in the Go’s standard library.\nNone of those structures is thread-safe. We will make them thread-safe in future posts (I wish).\nLet’s start by describing the most general one: the graph.\nGraph According to Wikipedia:\nA graph data structure consists of a finite (and possibly mutable) set of vertices (also called nodes or points), together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges (also called links or lines), and for a directed graph are also known as arrows. The vertices may be part of the graph structure or may be external entities represented by integer indices or references.\nSo a graph is be a set $$G = (V,E)$$, where $$V$$ is a set of vertex (or nodes) and $$E$$ is a set of edges. We will focus on the undirected graph, but creating a directed graph from an undirected one is quite easy.\nIn the above graph, $$V = (a, b, c, d, e)$$ and $$E = ((a,b), (a,c), (c,d), (d,e), (e,a))$$.\nFor a more detailed (and theoretical) description of graphs and their application, you could read the book Algorithm Design.\nNow it’s the coding time!\nAs usual, let’s start with defining our structures:\npackage graph import ( \"fmt\" \"strings\" ) type Node struct { value interface{} } type Graph struct { nodes []*Node edges map[Node][]*Node } func NewGraph() *Graph { return \u0026Graph{ nodes: make([]*Node, 0), edges: make(map[Node][]*Node), } } As you can see from the code above, a Node is just a container for a value which is an interface{} so that we can use whatever type we want.\nA Graph, instead, contains both an array of pointers to Nodes and a map which has Nodes as key and an array of pointers to Nodes as value.\nThis definition follows naturally the formal definition, so we defined a Graph as a pair of nodes and edges.\nThe NewGraph function only initializes nodes and edges.\nLet’s see how to add nodes and edges:\nfunc (g *Graph) AddNode(el interface{}) *Node { n := \u0026Node{el} g.nodes = append(g.nodes, n) return n } func (g *Graph) AddEdge(n1, n2 *Node) { g.edges[*n1] = append(g.edges[*n1], n2) g.edges[*n2] = append(g.edges[*n2], n1) } Both the AddNode and AddEdge methods are easy to understand.\nAddNode creates a Node which wraps the element, appends it to the node array and returns a pointer to that Node. This pointer can be useful next.\nAddEdge takes two pointers to Nodes and appends them to the edge list in the map of each node.\nfunc (n Node) String() string { return fmt.Sprintf(\"%v\", n.value) } func (g Graph) String() string { sb := strings.Builder{} for _, v := range g.nodes { sb.WriteString(v.String()) sb.WriteString(\" -\u003e [ \") neighbors := g.edges[*v] for _, u := range neighbors { sb.WriteString(u.String()) sb.WriteString(\" \") } sb.WriteString(\"]\\n\") } return sb.String() } The String method for the Node is trivial, while the String method for a Graph needs a explanation. We first create a strings.Builder which is the most efficient way to store a string incrementally. We then iterate over each Node and over each edge of that node. Let’s take the graph represented above: to create it in our code we could run the following snipped of code:\ng := NewGraph() nA := g.AddNode(\"a\") nB := g.AddNode(\"b\") nC := g.AddNode(\"c\") nD := g.AddNode(\"d\") nE := g.AddNode(\"e\") g.AddEdge(nA, nB) g.AddEdge(nA, nC) g.AddEdge(nA, nE) g.AddEdge(nC, nD) g.AddEdge(nD, nE) fmt.Print(g.String()) Eventually, the Print statement will print the following:\na -\u003e [ b c e ] b -\u003e [ a ] c -\u003e [ a d ] d -\u003e [ c e ] e -\u003e [ a d ] Tree According to Wikipedia:\nIn graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph. A forest is an undirected graph in which any two vertices are connected by at most one path, or equivalently an acyclic undirected graph, or equivalently a disjoint union of trees.\nGenerally speaking, a tree is a graph without cycles on which we could define a parent-children relationship.\nThe recursive definition of a tree is:\nA tree is $$empty$$ or a vertex $$r$$ (the root of the tree) and a set of trees (the subtrees of $$T$$) whose roots are the children of $$r$$.\nThis definition helps us to understand the basic structure of a tree. So we could decompose a tree in many subtrees.\nA tree is a collection of nodes connected by directed edges. It is a nonlinear data structure, compared to arrays, linked lists, stacks and queues which are linear data structures. A tree can be empty with no nodes or a tree is a structure consisting of one node called the root and zero or one or more subtrees. A tree has the following general properties:\none node is distinguished as a root; every node but the root is connected by a directed edge from exactly one other node; a direction is: $$parent \\rightarrow children$$ In the above tree we have a root $$r$$ having $$a$$, $$b$$ and $$c$$ as child. Subtrees of this tree are:\n($$a$$, $$d$$), having $$a$$ as the root and $$d$$ as child of $$a$$; $$b$$, having $$b$$ as the root and the empty tree as child of $$b$$; $$c$$, having $$c$$ as the root and the empty tree as child of $$c$$; $$d$$, having $$d$$ as the root and the empty tree as child of $$d$$. For a more detailed (and theoretical) description of trees and their application, you could read the book Algorithm Design.\nNow let’s translate this formal definition into code:\npackage tree type Tree struct { el interface{} child []*Tree } func (t *Tree) AddChild(el interface{}) *Tree { c := \u0026Tree{el: el} t.child = append(t.child, c) return c } Code for Tree is quite easy, isn’t it?\nJust think about the formal definition and see how we translate it in code:\nA Tree struct contains an element el and a set (an array) of other Trees (child). When we add a child to a Tree using the AddChild method we create a new Tree with el as the element and no child, then we append this tree to the root.\nTo represent the above tree, we could run the following snippet:\nt := Tree{el: \"r\"} a := t.AddChild(\"a\") a.AddChild(\"d\") t.AddChild(\"b\") t.AddChild(\"c\") Since this implementation is too easy, we’ll see how to implement the search using both BFS (breadth-first search) and DFS (depth-first search).\nBFS The BFS algorithm visits our tree level by level. A possible visit to our tree could be the following:\nLabels on the edges represent the order of visit.\nThe code for a BFS visit is the following:\nfunc (t *Tree) BFS(f func(*Tree)) { q := queue.Queue{} q.Enqueue(t) for !q.Empty() { next := q.Dequeue() nextNode := next.(*Tree) f(nextNode) if len(nextNode.child) \u003e 0 { for _, child := range nextNode.child { q.Enqueue(child) } } } } We create a queue containing all the nodes to be visited. The first node added is obviously t (the root). A for iterates over the queue and applies the function f passing the dequeued element next. After visiting the element next, its child will be added to the queue.\nTo print our tree using BFS we can run:\nt.BFS(func(c *Tree) { fmt.Println(c.el) }) This will print:\nr a b c d DFS The DFS algorithm visits each node of the tree trying to Go as deep as he can, then backtracking when encounters a node with no children (a leaf). A possible visit to our tree could be the following:\nCode for DFS is far more elegant that the one for BFS since it uses recursion:\nfunc (t *Tree) DFS(f func(*Tree)) { f(t) if len(t.child) \u003e 0 { for _, c := range t.child { c.DFS(f) } } } It first calls f passing t, then visits each child of t and calls DFS on each one.\nTo print our tree using BFS we can run:\nt.DFS(func(c *Tree) { fmt.Println(c.el) }) This will print\nr a d b c Conclusion Graphs and trees are powerful data structures since they allow you to store efficiently your data and their relationships. In literature, you can find so many different kinds of graphs and trees. A dept known of those structures makes you a better developer.\n“The question of whether a computer can think is no more interesting than the question of whether a submarine can swim.”\nEdsger W. Dijkstra\n",
  "wordCount" : "1567",
  "inLanguage": "en",
  "datePublished": "2020-01-10T17:05:35Z",
  "dateModified": "2020-01-10T17:05:35Z",
  "author":{
    "@type": "Person",
    "name": "Dario Di Pasquale"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dariodip.com/posts/algorithms/a-brief-introduction-to-data-structures-using-go-part-ii/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Dario Di Pasquale",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dariodip.com/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dariodip.com/" accesskey="h" title="Dario Di Pasquale (Alt + H)">Dario Di Pasquale</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dariodip.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://dariodip.com/portfolio/" title="Portfolio">
                    <span>Portfolio</span>
                </a>
            </li>
            <li>
                <a href="https://dariodip.com/posts/" title="Notes">
                    <span>Notes</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dariodip.com/">Home</a>&nbsp;»&nbsp;<a href="https://dariodip.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Data structures with Go - Part II
    </h1>
    <div class="post-description">
      A brief introduction to data structures using Go - Part II
    </div>
    <div class="post-meta"><span title='2020-01-10 17:05:35 +0000 UTC'>January 10, 2020</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Dario Di Pasquale</span>

</div>
  </header> 
  <div class="post-content"><h2 id="data-structures-with-go---part-ii">Data Structures With Go - Part II<a hidden class="anchor" aria-hidden="true" href="#data-structures-with-go---part-ii">#</a></h2>
<h6 id="this-page-has-been-migrated-to-medium">This page has been migrated to <a href="https://dariodip.medium.com/data-structures-with-go-part-ii-11f94e6adc46">Medium</a><a hidden class="anchor" aria-hidden="true" href="#this-page-has-been-migrated-to-medium">#</a></h6>
<p>In the <a href="https://dariodip.com/posts/2020/01/data-structures-with-go-part-i">previous post</a> we discussed how to implement linear data structures with Go.</p>
<p>Now we will explore two more complex data structures: <em>tree</em> and <em>graph</em>.</p>
<p>Those structures are not <em>Linear</em> and can represent unstructured information. Both <em>graph</em>s and <em>tree</em>s are the foundation of the <em>graph theory</em> and both can be used, essentially, to describe a kind of relation.</p>
<p>In the domain of <em>mathematics</em> and <em>computer science</em>, <strong>graph theory</strong> is the study of graphs that concerns with the relationship among edges and vertices. It is a popular subject having its applications in computer science, information technology, biosciences and mathematics to name a few.</p>
<p>The structures we will develop are only for educational purpose, you should not use them in production, also because some of them are already implemented in the <em>Go</em>&rsquo;s standard library.</p>
<p>None of those structures is thread-safe. We will make them <em>thread-safe</em> in future posts (I wish).</p>
<p>Let&rsquo;s start by describing the most general one: the <strong>graph</strong>.</p>
<h3 id="graph">Graph<a hidden class="anchor" aria-hidden="true" href="#graph">#</a></h3>
<p>According to <a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">Wikipedia</a>:</p>
<blockquote>
<p>A graph data structure consists of a finite (and possibly mutable) set of vertices (also called nodes or points), together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges (also called links or lines), and for a directed graph are also known as arrows. The vertices may be part of the graph structure or may be external entities represented by integer indices or references.</p></blockquote>
<p>So a <em>graph</em> is be a set $$G = (V,E)$$, where $$V$$ is a set of <em>vertex</em> (or <em>nodes</em>) and $$E$$ is a set of <em>edges</em>. We will focus on the undirected graph, but creating a directed graph from an undirected one is quite easy.</p>
<p><img alt="Graph" loading="lazy" src="https://dariodip.com/media/blog/p2/graph.png" title="A graph"></p>
<p>In the above graph, $$V = (a, b, c, d, e)$$ and $$E = ((a,b), (a,c), (c,d), (d,e), (e,a))$$.</p>
<p>For a more detailed (and theoretical) description of graphs and their application, you could read the book <a href="https://www.pearson.com/us/higher-education/program/Kleinberg-Algorithm-Design/PGM319216.html">Algorithm Design</a>.</p>
<p>Now it&rsquo;s the coding time!</p>
<p>As usual, let&rsquo;s start with defining our structures:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cf222e">package</span> <span style="color:#1f2328">graph</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">import</span> <span style="color:#1f2328">(</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0a3069">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0a3069">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">type</span> <span style="color:#1f2328">Node</span> <span style="color:#cf222e">struct</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">value</span> <span style="color:#cf222e">interface</span><span style="color:#1f2328">{}</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">type</span> <span style="color:#1f2328">Graph</span> <span style="color:#cf222e">struct</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">nodes</span> <span style="color:#1f2328">[]</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Node</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">edges</span> <span style="color:#cf222e">map</span><span style="color:#1f2328">[</span><span style="color:#1f2328">Node</span><span style="color:#1f2328">][]</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Node</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#6639ba">NewGraph</span><span style="color:#1f2328">()</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Graph</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> <span style="color:#0550ae">&amp;</span><span style="color:#1f2328">Graph</span><span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">nodes</span><span style="color:#1f2328">:</span> <span style="color:#6639ba">make</span><span style="color:#1f2328">([]</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Node</span><span style="color:#1f2328">,</span> <span style="color:#0550ae">0</span><span style="color:#1f2328">),</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">edges</span><span style="color:#1f2328">:</span> <span style="color:#6639ba">make</span><span style="color:#1f2328">(</span><span style="color:#cf222e">map</span><span style="color:#1f2328">[</span><span style="color:#1f2328">Node</span><span style="color:#1f2328">][]</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Node</span><span style="color:#1f2328">),</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>As you can see from the code above, a <code>Node</code> is just a container for a value which is an <code>interface{}</code> so that we can use whatever type we want.</p>
<p>A <code>Graph</code>, instead, contains both an array of pointers to <code>Node</code>s and a <code>map</code> which has <code>Node</code>s as <em>key</em> and an array of pointers to <code>Node</code>s as value.</p>
<p>This definition follows naturally the formal definition, so we defined a <code>Graph</code> as a pair of <code>nodes</code> and <code>edges</code>.</p>
<p>The <code>NewGraph</code> function only initializes <code>nodes</code> and <code>edges</code>.</p>
<p>Let&rsquo;s see how to add <em>nodes</em> and <em>edges</em>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">g</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Graph</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">AddNode</span><span style="color:#1f2328">(</span><span style="color:#1f2328">el</span> <span style="color:#cf222e">interface</span><span style="color:#1f2328">{})</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Node</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">n</span> <span style="color:#0550ae">:=</span> <span style="color:#0550ae">&amp;</span><span style="color:#1f2328">Node</span><span style="color:#1f2328">{</span><span style="color:#1f2328">el</span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">nodes</span> <span style="color:#1f2328">=</span> <span style="color:#6639ba">append</span><span style="color:#1f2328">(</span><span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">nodes</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">n</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> <span style="color:#1f2328">n</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">g</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Graph</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">AddEdge</span><span style="color:#1f2328">(</span><span style="color:#1f2328">n1</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">n2</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Node</span><span style="color:#1f2328">)</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">edges</span><span style="color:#1f2328">[</span><span style="color:#0550ae">*</span><span style="color:#1f2328">n1</span><span style="color:#1f2328">]</span> <span style="color:#1f2328">=</span> <span style="color:#6639ba">append</span><span style="color:#1f2328">(</span><span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">edges</span><span style="color:#1f2328">[</span><span style="color:#0550ae">*</span><span style="color:#1f2328">n1</span><span style="color:#1f2328">],</span> <span style="color:#1f2328">n2</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">edges</span><span style="color:#1f2328">[</span><span style="color:#0550ae">*</span><span style="color:#1f2328">n2</span><span style="color:#1f2328">]</span> <span style="color:#1f2328">=</span> <span style="color:#6639ba">append</span><span style="color:#1f2328">(</span><span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">edges</span><span style="color:#1f2328">[</span><span style="color:#0550ae">*</span><span style="color:#1f2328">n2</span><span style="color:#1f2328">],</span> <span style="color:#1f2328">n1</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>Both the <code>AddNode</code> and <code>AddEdge</code> methods are easy to understand.</p>
<p><code>AddNode</code> creates a <code>Node</code> which wraps the element, appends it to the <code>node</code> array and returns a pointer to that <code>Node</code>. This pointer can be useful next.</p>
<p><code>AddEdge</code> takes two pointers to <code>Node</code>s and appends them to the <code>edge</code> list in the <code>map</code> of each node.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">n</span> <span style="color:#1f2328">Node</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">String</span><span style="color:#1f2328">()</span> <span style="color:#cf222e">string</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> <span style="color:#1f2328">fmt</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Sprintf</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;%v&#34;</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">n</span><span style="color:#1f2328">.</span><span style="color:#1f2328">value</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">g</span> <span style="color:#1f2328">Graph</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">String</span><span style="color:#1f2328">()</span> <span style="color:#cf222e">string</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">sb</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">strings</span><span style="color:#1f2328">.</span><span style="color:#1f2328">Builder</span><span style="color:#1f2328">{}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span> <span style="color:#1f2328">_</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">v</span> <span style="color:#0550ae">:=</span> <span style="color:#cf222e">range</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">nodes</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">sb</span><span style="color:#1f2328">.</span><span style="color:#6639ba">WriteString</span><span style="color:#1f2328">(</span><span style="color:#1f2328">v</span><span style="color:#1f2328">.</span><span style="color:#6639ba">String</span><span style="color:#1f2328">())</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">sb</span><span style="color:#1f2328">.</span><span style="color:#6639ba">WriteString</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34; -&gt; [ &#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">neighbors</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#1f2328">edges</span><span style="color:#1f2328">[</span><span style="color:#0550ae">*</span><span style="color:#1f2328">v</span><span style="color:#1f2328">]</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span> <span style="color:#1f2328">_</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">u</span> <span style="color:#0550ae">:=</span> <span style="color:#cf222e">range</span> <span style="color:#1f2328">neighbors</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">sb</span><span style="color:#1f2328">.</span><span style="color:#6639ba">WriteString</span><span style="color:#1f2328">(</span><span style="color:#1f2328">u</span><span style="color:#1f2328">.</span><span style="color:#6639ba">String</span><span style="color:#1f2328">())</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">sb</span><span style="color:#1f2328">.</span><span style="color:#6639ba">WriteString</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34; &#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">sb</span><span style="color:#1f2328">.</span><span style="color:#6639ba">WriteString</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;]\n&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> <span style="color:#1f2328">sb</span><span style="color:#1f2328">.</span><span style="color:#6639ba">String</span><span style="color:#1f2328">()</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>The <code>String</code> method for the <code>Node</code> is trivial, while the <code>String</code> method for a <code>Graph</code> needs a explanation. We first create a <code>strings.Builder</code> which is the most efficient way to store a string incrementally. We then iterate over each <code>Node</code> and over each <em>edge</em> of that node. Let&rsquo;s take the graph represented above: to create it in our code we could run the following snipped of code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#1f2328">g</span> <span style="color:#0550ae">:=</span> <span style="color:#6639ba">NewGraph</span><span style="color:#1f2328">()</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">nA</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddNode</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;a&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">nB</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddNode</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;b&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">nC</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddNode</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;c&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">nD</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddNode</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;d&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">nE</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddNode</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;e&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddEdge</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nA</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">nB</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddEdge</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nA</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">nC</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddEdge</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nA</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">nE</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddEdge</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nC</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">nD</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddEdge</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nD</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">nE</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">fmt</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Print</span><span style="color:#1f2328">(</span><span style="color:#1f2328">g</span><span style="color:#1f2328">.</span><span style="color:#6639ba">String</span><span style="color:#1f2328">())</span>
</span></span></code></pre></div><p>Eventually, the <code>Print</code> statement will print the following:</p>
<pre tabindex="0"><code>a -&gt; [ b c e ]
b -&gt; [ a ]
c -&gt; [ a d ]
d -&gt; [ c e ]
e -&gt; [ a d ]
</code></pre><h3 id="tree">Tree<a hidden class="anchor" aria-hidden="true" href="#tree">#</a></h3>
<p>According to <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">Wikipedia</a>:</p>
<blockquote>
<p>In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph. A forest is an undirected graph in which any two vertices are connected by at most one path, or equivalently an acyclic undirected graph, or equivalently a disjoint union of trees.</p></blockquote>
<p>Generally speaking, a <em>tree</em> is a <em>graph</em> without cycles on which we could define a <em>parent-children</em> relationship.</p>
<p>The recursive definition of a <em>tree</em> is:</p>
<blockquote>
<p>A tree is $$empty$$ or a vertex $$r$$ (the root of the tree) and a set of trees (the subtrees of $$T$$) whose roots are the children of $$r$$.</p></blockquote>
<p>This definition helps us to understand the basic structure of a <em>tree</em>. So we could decompose a <em>tree</em> in many <em>subtrees</em>.</p>
<p>A <em>tree</em> is a collection of nodes connected by directed edges. It is a nonlinear data structure, compared to arrays, linked lists, stacks and queues which are <a href="https://dariodip.com/posts/2020/01/data-structures-with-go-part-i">linear data structures</a>. A tree can be empty with no nodes or a tree is a structure consisting of one node called the root and zero or one or more subtrees. A tree has the following general properties:</p>
<ul>
<li>one node is distinguished as a root;</li>
<li>every node but the root is connected by a directed edge from exactly one other node;</li>
<li>a direction is: $$parent \rightarrow children$$</li>
</ul>
<p><img alt="Tree" loading="lazy" src="https://dariodip.com/media/blog/p2/tree-repr.png" title="A tree"></p>
<p>In the above <em>tree</em> we have a <strong>root</strong> $$r$$ having $$a$$, $$b$$ and $$c$$ as child.
<em>Subtrees</em> of this <em>tree</em> are:</p>
<ul>
<li>($$a$$, $$d$$), having $$a$$ as the root and $$d$$ as child of $$a$$;</li>
<li>$$b$$, having $$b$$ as the root and the empty tree as child of $$b$$;</li>
<li>$$c$$, having $$c$$ as the root and the empty tree as child of $$c$$;</li>
<li>$$d$$, having $$d$$ as the root and the empty tree as child of $$d$$.</li>
</ul>
<p>For a more detailed (and theoretical) description of trees and their application, you could read the book <a href="https://www.pearson.com/us/higher-education/program/Kleinberg-Algorithm-Design/PGM319216.html">Algorithm Design</a>.</p>
<p>Now let&rsquo;s translate this formal definition into code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cf222e">package</span> <span style="color:#1f2328">tree</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">type</span> <span style="color:#1f2328">Tree</span> <span style="color:#cf222e">struct</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">el</span> 		<span style="color:#cf222e">interface</span><span style="color:#1f2328">{}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">child</span> 	<span style="color:#1f2328">[]</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">t</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">AddChild</span><span style="color:#1f2328">(</span><span style="color:#1f2328">el</span> <span style="color:#cf222e">interface</span><span style="color:#1f2328">{})</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">c</span> <span style="color:#0550ae">:=</span> <span style="color:#0550ae">&amp;</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">{</span><span style="color:#1f2328">el</span><span style="color:#1f2328">:</span> <span style="color:#1f2328">el</span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#1f2328">child</span> <span style="color:#1f2328">=</span> <span style="color:#6639ba">append</span><span style="color:#1f2328">(</span><span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#1f2328">child</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">c</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">return</span> <span style="color:#1f2328">c</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>Code for <code>Tree</code> is quite easy, isn&rsquo;t it?</p>
<p>Just think about the formal definition and see how we translate it in code:</p>
<p>A <code>Tree</code> struct contains an element <code>el</code> and a set (an array) of other <code>Tree</code>s (<code>child</code>). When we add a child to a <code>Tree</code> using the <code>AddChild</code> method we create a new <code>Tree</code> with <code>el</code> as the element and no child, then we append this <em>tree</em> to the root.</p>
<p>To represent the above tree, we could run the following snippet:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#1f2328">t</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">Tree</span><span style="color:#1f2328">{</span><span style="color:#1f2328">el</span><span style="color:#1f2328">:</span> <span style="color:#0a3069">&#34;r&#34;</span><span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">a</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddChild</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;a&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">a</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddChild</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;d&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddChild</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;b&#34;</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#6639ba">AddChild</span><span style="color:#1f2328">(</span><span style="color:#0a3069">&#34;c&#34;</span><span style="color:#1f2328">)</span>
</span></span></code></pre></div><p>Since this implementation is too easy, we&rsquo;ll see how to implement the search using both <em>BFS</em> (breadth-first search) and <em>DFS</em> (depth-first search).</p>
<h4 id="bfs">BFS<a hidden class="anchor" aria-hidden="true" href="#bfs">#</a></h4>
<p>The <em>BFS</em> algorithm visits our tree level by level. A possible visit to our tree could be the following:</p>
<p><img alt="BFS" loading="lazy" src="https://dariodip.com/media/blog/p2/bfs.png" title="A BFS visit"></p>
<p>Labels on the edges represent the order of visit.</p>
<p>The code for a <em>BFS</em> visit is the following:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">t</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">BFS</span><span style="color:#1f2328">(</span><span style="color:#1f2328">f</span> <span style="color:#cf222e">func</span><span style="color:#1f2328">(</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">))</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">q</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">queue</span><span style="color:#1f2328">.</span><span style="color:#1f2328">Queue</span><span style="color:#1f2328">{}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">q</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Enqueue</span><span style="color:#1f2328">(</span><span style="color:#1f2328">t</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">for</span> <span style="color:#1f2328">!</span><span style="color:#1f2328">q</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Empty</span><span style="color:#1f2328">()</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">next</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">q</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Dequeue</span><span style="color:#1f2328">()</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">nextNode</span> <span style="color:#0550ae">:=</span> <span style="color:#1f2328">next</span><span style="color:#1f2328">.(</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#6639ba">f</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nextNode</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">if</span> <span style="color:#6639ba">len</span><span style="color:#1f2328">(</span><span style="color:#1f2328">nextNode</span><span style="color:#1f2328">.</span><span style="color:#1f2328">child</span><span style="color:#1f2328">)</span> <span style="color:#1f2328">&gt;</span> <span style="color:#0550ae">0</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#cf222e">for</span> <span style="color:#1f2328">_</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">child</span> <span style="color:#0550ae">:=</span> <span style="color:#cf222e">range</span> <span style="color:#1f2328">nextNode</span><span style="color:#1f2328">.</span><span style="color:#1f2328">child</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>				<span style="color:#1f2328">q</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Enqueue</span><span style="color:#1f2328">(</span><span style="color:#1f2328">child</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>We create a <em>queue</em> containing all the nodes to be visited. The first node added is obviously <em>t</em> (the root). A <em>for</em> iterates over the queue and applies the function <em>f</em> passing the dequeued element <em>next</em>. After visiting the element <em>next</em>, its child will be added to the queue.</p>
<p>To print our <em>tree</em> using <em>BFS</em> we can run:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#6639ba">BFS</span><span style="color:#1f2328">(</span><span style="color:#cf222e">func</span><span style="color:#1f2328">(</span><span style="color:#1f2328">c</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">)</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">fmt</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Println</span><span style="color:#1f2328">(</span><span style="color:#1f2328">c</span><span style="color:#1f2328">.</span><span style="color:#1f2328">el</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">})</span>
</span></span></code></pre></div><p>This will print:</p>
<pre tabindex="0"><code>r
a
b
c
d
</code></pre><h4 id="dfs">DFS<a hidden class="anchor" aria-hidden="true" href="#dfs">#</a></h4>
<p>The <em>DFS</em> algorithm visits each node of the tree trying to Go as deep as he can, then <em>backtracking</em> when encounters a node with no children (a <em>leaf</em>). A possible visit to our tree could be the following:</p>
<p><img alt="DFS" loading="lazy" src="https://dariodip.com/media/blog/p2/dfs.png" title="A DFS visit"></p>
<p>Code for <em>DFS</em> is far more elegant that the one for <em>BFS</em> since it uses recursion:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#cf222e">func</span> <span style="color:#1f2328">(</span><span style="color:#1f2328">t</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">)</span> <span style="color:#6639ba">DFS</span><span style="color:#1f2328">(</span><span style="color:#1f2328">f</span> <span style="color:#cf222e">func</span><span style="color:#1f2328">(</span><span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">))</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6639ba">f</span><span style="color:#1f2328">(</span><span style="color:#1f2328">t</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#cf222e">if</span> <span style="color:#6639ba">len</span><span style="color:#1f2328">(</span><span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#1f2328">child</span><span style="color:#1f2328">)</span> <span style="color:#1f2328">&gt;</span> <span style="color:#0550ae">0</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#cf222e">for</span> <span style="color:#1f2328">_</span><span style="color:#1f2328">,</span> <span style="color:#1f2328">c</span> <span style="color:#0550ae">:=</span> <span style="color:#cf222e">range</span> <span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#1f2328">child</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#1f2328">c</span><span style="color:#1f2328">.</span><span style="color:#6639ba">DFS</span><span style="color:#1f2328">(</span><span style="color:#1f2328">f</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">}</span>
</span></span><span style="display:flex;"><span><span style="color:#1f2328">}</span>
</span></span></code></pre></div><p>It first calls <code>f</code> passing <code>t</code>, then visits each child of <code>t</code> and calls <code>DFS</code> on each one.</p>
<p>To print our <em>tree</em> using <em>BFS</em> we can run:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#1f2328">t</span><span style="color:#1f2328">.</span><span style="color:#6639ba">DFS</span><span style="color:#1f2328">(</span><span style="color:#cf222e">func</span><span style="color:#1f2328">(</span><span style="color:#1f2328">c</span> <span style="color:#0550ae">*</span><span style="color:#1f2328">Tree</span><span style="color:#1f2328">)</span> <span style="color:#1f2328">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#1f2328">fmt</span><span style="color:#1f2328">.</span><span style="color:#6639ba">Println</span><span style="color:#1f2328">(</span><span style="color:#1f2328">c</span><span style="color:#1f2328">.</span><span style="color:#1f2328">el</span><span style="color:#1f2328">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#1f2328">})</span>
</span></span></code></pre></div><p>This will print</p>
<pre tabindex="0"><code>r
a
d
b
c
</code></pre><h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Graphs and trees are powerful data structures since they allow you to store efficiently your data and their relationships. In literature, you can find so many different kinds of graphs and trees. A dept known of those structures makes you a better developer.</p>
<blockquote>
<p>&ldquo;The question of whether a computer can think is no more interesting than the question of whether a submarine can swim.&rdquo;</p>
<p><em>Edsger W. Dijkstra</em></p></blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dariodip.com/tags/algorithms/">Algorithms</a></li>
      <li><a href="https://dariodip.com/tags/go/">Go</a></li>
      <li><a href="https://dariodip.com/tags/golang/">Golang</a></li>
      <li><a href="https://dariodip.com/tags/data-structures/">Data Structures</a></li>
      <li><a href="https://dariodip.com/tags/basic/">Basic</a></li>
      <li><a href="https://dariodip.com/tags/beginner/">Beginner</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://dariodip.com/posts/devops/a-brief-introduction-to-ansible/">
    <span class="title">« Prev</span>
    <br>
    <span>Ansible for developers 101</span>
  </a>
  <a class="next" href="https://dariodip.com/posts/algorithms/a-brief-introduction-to-data-structures-using-go/">
    <span class="title">Next »</span>
    <br>
    <span>Data structures with Go - Part I</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://dariodip.com/">Dario Di Pasquale</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
